; ismétlés:
; (cons fej farok): visszaad egy új listát, aminek feje fej, fara farok
; pl:
(writeln (cons 1 (list 2 3)))
; append A B receptje:
; Az A-t szedem szét
; ha A üres, akkor az eredmény: B
(writeln (append empty (list 3 4 5)))
; Ha A nem üres, akkor szétszedem fejre és farokra
; reku hívás, ennek az eredményét beteszem farok-érték-be
; farok erte elé odateszem a fejA-t a cons-sal

(define (my-append A B)
    (cond
        [(empty? A) B]
        [else 
            (define fejA    (first A))
            (define farokA (rest A))
            (define farok-ertek (my-append farokA B))
            ; megtartom a fejet
            (cons fejA farok-ertek)]))
            
(writeln (my-append (list 1 2 3) (list 4 5 6)))

; páros-filter lst: kiszűri a páros számokat, azokat egy listaként adja vissza
; hint: even? x, igaz ha x páros
; ha üres akkor üres listát ad vissza
; ha nem üres szétszedem fejre és farokra
; rekuval kiszámolom farok-értékét
; ha a fej páros, akkor megtartom, egyébként eldobom, azaz csak a farok-értékét adom vissza

(define (páros-filter lst)
    (cond
        [(empty? lst) empty]
        [else
            (define fej (first lst))
            (define farok (rest lst))
            (define farok-érték (páros-filter farok))
            (if (even? fej)
                ; igaz ágban megtartom
                (cons fej farok-érték)
                ; hamis ágban eldobom
                farok-érték)]))
(writeln (páros-filter (list 1 2 3 4 5 6)))

; Új anyag:
; nincs külön halmaz adatszerk, a listát használom halmazként
; ha listaként használom, akkor a sorrend mind1, azaz
; (list 1 2 3) == (list 3 2 1), mert mindegy a sorrend 
; (list 1 2 3) == (list 2 1 3), mert a sorrend nem számít
; a gyakoriság sem számít, ezért, mint halmaz, ezek egyenlőek:
; (list 1 2 3) == (list 1 2 1 3 1 2), mert teljesen mindegy hányszor vannak benne az értékek
; halmaz kezelés alapművelete, az: eleme-e
; angolul: is-member
; beépített fgv neve: member
; két paraméteres: (member x lst)
; megnézi, hogy az x elem benne van-e az lst-ben
; egy kicsit furán működik, de azért jó:
(writeln (member 1 (list 2 1 3)))
(writeln (member 5 (list 2 1 3)))
; a hülye racketben sémákban illetve list-ben ami nem false az true
(define (eleme-e x lst)
    (if member x lst)
    true
    false)
(writeln (eleme-e 1 (list 2 1 3)))
(writeln (eleme-e 5 (list 2 1 3)))
; ha valami nem false akkor az true
; minden halmaz műveletet a member-re vezetünk vissza
; (intersection A B) visszaadja a metszetben lévő elemeket, azaz azokat az elemeket amik benne vannak A-ban is és B-ben is 
; (intersection empty B) = empty
; ha nem üres az A, akkor szétszedem fejre és farokra
; ha a fej benne van a B-ben, akkor megtartom, egyébként eldobom
; feladat: írjátok meg az intersection-t

(define (intersection A B)
    (cond
        [(empty? A) empty]
        [else
            (define fejA (first A))
            (define farokA (rest A))
            (define farok-érték (intersection farokA B))
            (if (member fejA B)
                (cons fejA farok-érték)
                farok-érték)]))
                
(writeln (intersection (list 1 2 3) (list 2 3 4)))

; ha fejA benne van B-ben, akkor eldobom,
; mert felesleges, hogy kétszer legyen benne az eredmény
; (unio A B), azok az elemek amik vagy A-ban vagy B-ben szerepelnek

; részhalmaz A B
; (subset A B): igazat ad, ha A minden eleme benne van B-ben,
; egyébként hamisat
; (subset (list 1 2) (list 2 5 1 3)) = igaz
; minden halmaz művelet a member-re vezetünk vissza
; az üres lista minden listának, pl: az üres listának is, a részhalmaza

(define (subset A B)
    (cond
        [(empty? A) true]
        [else
            (define fejA (first A))
            (define farokA (rest A))
            (define farok-érték(subset farokA B))
            (if (member fejA B)
                farok-érték
                false)]))
                
(writeln (subset (list 1 2 6) (list 2 5 1 3)))
; halmaz egyenlőség
; angolul: (set-equ A B), ez akkor ad vissza igazat, ha A részhalmaza B-nek, és
; B részhalmaza A-nak
; hint: itt nem kell reku, csak két hívás és egy and

(define (set-equ A B) (and (subset A B) (subset B A)))
(writeln (set-equ (list 1 2 3) (list 2 1 1 3 2 1 2 3 1)))
; kevesebb mint 8perc alatt, írjunk saját member-t
; (my-member x lst):
; hint ha lst feje = x, akkor return true

(define (my-member x lst)
    (cond
        [(empty? lst) false]
        [else
            (define fej (first lst))
            (define farok (rest lst))
            (define farok-érték (my-member x farok))
            (if (= fej x)
            true
            farok-érték)]))
